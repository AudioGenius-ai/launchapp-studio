# Code Pilot Studio v2 - Plugins

This directory contains Tauri plugins that extend the functionality of Code Pilot Studio v2. Each plugin is a self-contained Rust crate with TypeScript bindings for frontend integration.

## Plugin Architecture

All plugins follow Tauri v2's plugin architecture, providing:
- **Modularity**: Each feature is isolated in its own plugin
- **Type Safety**: Auto-generated TypeScript bindings
- **Security**: Fine-grained permission system
- **Lifecycle Management**: Proper setup and teardown hooks
- **State Management**: Each plugin manages its own state
- **Event System**: Built-in event emission for real-time updates

## Available Plugins

### 🤖 [tauri-plugin-claude](./tauri-plugin-claude/) ✅ Implemented
AI-powered coding assistance through Anthropic's Claude CLI integration.
- Session management with persistence and recovery
- Real-time streaming responses with dual output capture
- MCP (Model Context Protocol) tool discovery and integration
- Process lifecycle management with orphan detection
- Session export/import functionality
- Multi-session support

### 📚 [tauri-plugin-git](./tauri-plugin-git/) ⚠️ Implemented (Compilation Issues)
Comprehensive Git version control integration using libgit2.
- Full Git operations (status, commit, branch, merge, etc.)
- Remote repository management (fetch, pull, push)
- Diff and blame functionality
- Stash and tag management
- Branch operations and history
- **Note**: Currently disabled due to libgit2 compilation issues

### 💻 [tauri-plugin-terminal](./tauri-plugin-terminal/) ✅ Implemented
Cross-platform terminal emulation with PTY support.
- Multiple concurrent terminal sessions
- Shell detection and configuration (bash, zsh, fish, PowerShell, cmd)
- Real-time input/output streaming
- Terminal resize and lifecycle management
- ANSI color support
- Process management with proper cleanup

### 🪟 [tauri-plugin-window-manager](./tauri-plugin-window-manager/) 🚧 In Development
Advanced window management and lifecycle control.
- Create and manage multiple application windows
- Window state persistence and restoration
- Inter-window messaging system
- Window positioning and sizing controls
- Theme management (light/dark/auto)
- Focus and visibility management

### 🌐 [tauri-plugin-mcp-webserver](./tauri-plugin-mcp-webserver/) ✅ Implemented
MCP (Model Context Protocol) server management for external processes.
- Process lifecycle management for MCP servers
- Automatic port allocation and health checking
- Support for bundled sidecars and external processes
- Tool discovery and execution via JSON-RPC
- Multiple concurrent server instances
- Real-time process monitoring

## Plugin Structure

Each plugin follows this standard structure:

```
tauri-plugin-{name}/
├── Cargo.toml                    # Rust dependencies
├── package.json                  # NPM package info
├── build.rs                      # Permission generation
├── src/
│   ├── lib.rs                   # Plugin setup & lifecycle
│   ├── commands.rs              # Tauri command handlers
│   ├── models.rs                # Data structures
│   └── {feature}_service.rs     # Core business logic
├── permissions/                  # Permission definitions
│   └── autogenerated/           # Generated from build.rs
└── guest-js/                    # TypeScript bindings
    ├── index.ts                 # Public API
    └── bindings.ts              # Auto-generated types
```

## Using Plugins

### Frontend Integration

```typescript
import { invoke } from '@tauri-apps/api/core';

// Claude plugin example
const session = await invoke('plugin:claude|create_session', {
    workspacePath: '/path/to/workspace'
});

// Git plugin example
const status = await invoke('plugin:git|git_status', {
    repoPath: '/path/to/repo'
});

// Terminal plugin example
const terminalId = await invoke('plugin:terminal|create_terminal', {
    shell: '/bin/bash',
    cwd: '/path/to/directory'
});

// MCP webserver plugin example
const instance = await invoke('plugin:mcp-webserver|start_server', {
    config: {
        name: 'my-mcp-server',
        command: 'launchapp-mcp-sidecar',
        args: []
    }
});
```

### Permission Configuration

In your app's `capabilities/default.json`:

```json
{
  "permissions": [
    "claude:default",
    "git:default",
    "terminal:default",
    "mcp-webserver:default",
    "shell:allow-execute",
    {
      "identifier": "shell:allow-execute",
      "allow": [
        {
          "name": "launchapp-mcp-sidecar",
          "sidecar": true
        }
      ]
    }
  ]
}
```

## Development

### Creating a New Plugin

```bash
# Generate plugin scaffolding
npx @tauri-apps/cli plugin new [name] --no-api

# Move to plugins directory
mv tauri-plugin-[name] plugins/

# Add to workspace
# Update root Cargo.toml members array
```

### Building Plugins

Plugins are built automatically as part of the main app build process:

```bash
cd apps/desktop
pnpm tauri:build
```

### Testing Plugins

Each plugin includes its own test suite:

```bash
# Run Rust tests
cd plugins/tauri-plugin-[name]
cargo test

# Run TypeScript tests (if applicable)
pnpm test
```

## Best Practices

1. **Command Naming**: Use descriptive command names prefixed with the feature (e.g., `git_status`, `terminal_create`)
2. **Error Handling**: Return proper error types with meaningful messages
3. **State Management**: Use plugin state for session data, not global state
4. **Async Operations**: Use async commands for long-running operations
5. **Resource Cleanup**: Implement proper cleanup in drop handlers

## Security Considerations

1. **Path Validation**: Always validate and sanitize file paths
2. **Command Injection**: Be careful with shell command execution
3. **Permission Scoping**: Define minimal required permissions
4. **Input Validation**: Validate all command inputs

## Contributing

When contributing to plugins:
1. Follow the existing plugin structure
2. Add comprehensive documentation
3. Include unit tests for new functionality
4. Update TypeScript bindings
5. Test cross-platform compatibility

## License

All plugins are part of Code Pilot Studio v2 and follow the main project's license.